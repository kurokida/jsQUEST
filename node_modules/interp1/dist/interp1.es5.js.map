{"version":3,"file":"interp1.es5.js","sources":["../src/interp1.ts"],"sourcesContent":["/**\n * Method of interpolation.\n */\nexport type InterpolationMethod = 'linear' | 'nearest' | 'next' | 'previous';\n\n/**\n * Point data type.\n */\ntype Point = [number, number];\n\n/**\n * Finds the index of range in which a query value is included in a sorted\n * array with binary search.\n * @param  xs Array sorted in ascending order.\n * @param  xq Query value.\n * @return    Index of range plus percentage to next index. \n */\nfunction binaryFindIndex(\n  xs: ReadonlyArray<number>,\n  xq: number,\n): number {\n  /* Special case of only one element in array. */\n  if (xs.length === 1 && xs[0] === xq) return 0;\n\n  /* Determine bounds. */\n  let lower: number = 0;\n  let upper: number = xs.length - 1;\n\n  /* Find index of range. */\n  while (lower < upper) {\n    /* Determine test range. */\n    const mid: number = Math.floor((lower + upper) / 2);\n    const prev: number = xs[mid];\n    const next: number = xs[mid + 1];\n    if (xq < prev) {\n      /* Query value is below range. */\n      upper = mid;\n    } else if (xq > next) {\n      /* Query value is above range. */\n      lower = mid + 1;\n    } else {\n      /* Query value is in range. */\n      return mid + (xq - prev) / (next - prev); \n    }\n  }\n\n  /* Range not found. */\n  return -1;\n}\n\n/**\n * Interpolates a value.\n * @param  vs     Array of values to interpolate between.\n * @param  index  Index of new to be interpolated value.\n * @param  method Kind of interpolation. Can be 'linear', 'nearest', 'next' or 'previous'.\n * @return        Interpolated value.\n */\nfunction interpolate(\n  vs: ReadonlyArray<number>,\n  index: number,\n  method: InterpolationMethod,\n): number {\n  switch (method) {\n    case 'nearest': {\n      return vs[Math.round(index)]\n    }\n    case 'next': {\n      return vs[Math.ceil(index)];\n    }\n    case 'previous': {\n      return vs[Math.floor(index)];\n    }\n    case 'linear':\n    default: {\n      const prev: number = Math.floor(index);\n      const next: number = Math.ceil(index);\n      const lambda: number = index - prev;\n      return (1 - lambda) * vs[prev] + lambda * vs[next];\n    }\n  }\n}\n\n/**\n * Interpolates values linearly in one dimension.\n * @param  xs     Array of independent sample points.\n * @param  vs     Array of dependent values v(x) with length equal to xs.\n * @param  xqs    Array of query points.\n * @param  method Method of interpolation.\n * @return        Interpolated values vq(xq) with length equal to xqs.\n */\nexport default function interp1(\n  xs: ReadonlyArray<number>,\n  vs: ReadonlyArray<number>,\n  xqs: ReadonlyArray<number>,\n  method: InterpolationMethod = 'linear',\n): number[] {\n  /*\n   * Throws an error if number of independent sample points is not equal to\n   * the number of dependent values.\n   */\n  if (xs.length !== vs.length) {\n    throw new Error(\n      `Arrays of sample points xs and corresponding values vs have to have\n      equal length.`\n    );\n  }\n\n  /* Combine x and v arrays. */\n  const zipped: Point[] = xs.map((x, index) => [x, vs[index]]);\n\n  /* Sort points by independent variabel in ascending order. */\n  zipped.sort((a, b) => {\n    const diff: number = a[0] - b[0];\n\n    /* Check if some x value occurs twice. */\n    if (diff === 0) {\n      throw new Error(\n        'Two sample points have equal value ' + a[0] + '. This is not allowed.'\n      );\n    }\n\n    return diff;\n  });\n\n  /* Extract sorted x and v arrays */\n  const sortedX: number[] = [];\n  const sortedV: number[] = [];\n  for (let i: number = 0; i < zipped.length; i++) {\n    const point: Point = zipped[i];\n    sortedX.push(point[0]);\n    sortedV.push(point[1]);\n  }\n\n  /* Interpolate values */\n  const yqs: ReadonlyArray<number> = xqs.map(xq => {\n    /* Determine index of range of query value. */\n    const index: number = binaryFindIndex(sortedX, xq);\n\n    /* Check if value lies in interpolation range. */\n    if (index === -1) {\n      throw new Error(\n        `Query value ` + xq + ` lies outside of range. Extrapolation is not\n        supported.`\n      );\n    }\n\n    /* Interpolate value. */\n    return interpolate(sortedV, index, method);\n  });\n\n  /* Return result. */\n  return yqs.slice();\n}\n"],"names":[],"mappings":"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"}